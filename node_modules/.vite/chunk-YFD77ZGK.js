// node_modules/@builder.io/qwik/core.mjs
var qDev = true;
var qTest = globalThis.describe !== void 0;
var EMPTY_ARRAY = [];
var EMPTY_OBJ = {};
if (qDev) {
  Object.freeze(EMPTY_ARRAY);
  Object.freeze(EMPTY_OBJ);
}
var STYLE = qDev ? `background: #564CE0; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;` : "";
var logError = (message, ...optionalParams) => {
  console.error("%cQWIK ERROR", STYLE, message, ...optionalParams);
};
var logWarn = (message, ...optionalParams) => {
  console.warn("%cQWIK WARN", STYLE, message, ...optionalParams);
};
var logDebug = (message, ...optionalParams) => {
  console.debug("%cQWIK", STYLE, message, ...optionalParams);
};
function assertDefined(value, text) {
  if (qDev) {
    if (value != null)
      return;
    throw newError(text || "Expected defined value.");
  }
}
function assertEqual(value1, value2, text) {
  if (qDev) {
    if (value1 === value2)
      return;
    throw newError(text || `Expected '${value1}' === '${value2}'.`);
  }
}
function newError(text) {
  debugger;
  const error = new Error(text);
  logError(error);
  return error;
}
var QHostAttr = "q:host";
var OnRenderProp = "q:renderFn";
var ComponentScopedStyles = "q:sstyle";
var ComponentStylesPrefixHost = "\u{1F48E}";
var ComponentStylesPrefixContent = "\u2B50\uFE0F";
var QSlotAttr = "q:slot";
var QObjAttr = "q:obj";
var QContainerAttr = "q:container";
var QContainerSelector = "[q\\:container]";
var ELEMENT_ID = "q:id";
var ELEMENT_ID_PREFIX = "#";
function getDocument(node) {
  if (typeof document !== "undefined") {
    return document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  let doc = node.ownerDocument;
  while (doc && doc.nodeType !== 9) {
    doc = doc.parentNode;
  }
  assertDefined(doc);
  return doc;
}
function isStyleTask(obj) {
  return obj && typeof obj === "object" && obj.type === "style";
}
var _context;
function tryGetInvokeContext() {
  if (!_context) {
    const context = typeof document !== "undefined" && document && document.__q_context__;
    if (!context) {
      return void 0;
    }
    if (Array.isArray(context)) {
      const element = context[0];
      const hostElement = getHostElement(element);
      assertDefined(element);
      return document.__q_context__ = newInvokeContext(getDocument(element), hostElement, element, context[1], context[2]);
    }
    return context;
  }
  return _context;
}
function getInvokeContext() {
  const ctx = tryGetInvokeContext();
  if (!ctx) {
    throw new Error("Q-ERROR: invoking 'use*()' method outside of invocation context.");
  }
  return ctx;
}
function useInvoke(context, fn, ...args) {
  const previousContext = _context;
  let returnValue;
  try {
    _context = context;
    returnValue = fn.apply(null, args);
  } finally {
    const currentCtx = _context;
    _context = previousContext;
    if (currentCtx.waitOn && currentCtx.waitOn.length > 0) {
      return Promise.all(currentCtx.waitOn).then(() => returnValue);
    }
  }
  return returnValue;
}
function newInvokeContext(doc, hostElement, element, event, url) {
  return {
    doc,
    hostElement,
    element,
    event,
    url: url || null,
    qrl: void 0,
    subscriptions: event === "qRender"
  };
}
function useWaitOn(promise) {
  const ctx = getInvokeContext();
  (ctx.waitOn || (ctx.waitOn = [])).push(promise);
}
function getHostElement(el) {
  let foundSlot = false;
  let node = el;
  while (node) {
    const isHost = node.hasAttribute(QHostAttr);
    const isSlot = node.tagName === "Q:SLOT";
    if (isHost) {
      if (!foundSlot) {
        break;
      } else {
        foundSlot = false;
      }
    }
    if (isSlot) {
      foundSlot = true;
    }
    node = node.parentElement;
  }
  return node;
}
function getContainer(el) {
  return el.closest(QContainerSelector);
}
function isQrl(value) {
  return value instanceof QRLInternal;
}
var QRL = class {
  constructor(chunk, symbol, symbolRef, symbolFn, capture, captureRef) {
    this.chunk = chunk;
    this.symbol = symbol;
    this.symbolRef = symbolRef;
    this.symbolFn = symbolFn;
    this.capture = capture;
    this.captureRef = captureRef;
    this.canonicalChunk = chunk.replace(FIND_EXT, "");
  }
  setContainer(el) {
    if (!this.el) {
      this.el = el;
    }
  }
  async resolve(el) {
    if (el) {
      this.setContainer(el);
    }
    return qrlImport(this.el, this);
  }
  invokeFn() {
    return async (...args) => {
      const currentCtx = tryGetInvokeContext();
      const fn = typeof this.symbolRef === "function" ? this.symbolRef : await this.resolve();
      if (typeof fn === "function") {
        const context = Object.assign(Object.assign(Object.assign({}, newInvokeContext()), currentCtx), { qrl: this });
        return useInvoke(context, fn, ...args);
      }
      throw new Error("QRL is not a function");
    };
  }
  copy() {
    return new QRLInternal(this.chunk, this.symbol, this.symbolRef, this.symbolFn, null, this.captureRef);
  }
  async invoke(...args) {
    const fn = this.invokeFn();
    return fn(...args);
  }
  serialize(options) {
    return stringifyQRL(this, options);
  }
};
var QRLInternal = QRL;
var FIND_EXT = /\?[\w=&]+$/;
function flattenArray(array, dst) {
  if (!dst)
    dst = [];
  for (const item of array) {
    if (Array.isArray(item)) {
      flattenArray(item, dst);
    } else {
      dst.push(item);
    }
  }
  return dst;
}
function isPromise(value) {
  return value instanceof Promise;
}
var then = (promise, thenFn) => {
  return isPromise(promise) ? promise.then(thenFn) : thenFn(promise);
};
var promiseAll = (promises) => {
  const hasPromise = promises.some(isPromise);
  if (hasPromise) {
    return Promise.all(promises);
  }
  return promises;
};
var createPlatform = (doc) => {
  const moduleCache = /* @__PURE__ */ new Map();
  return {
    importSymbol(element, url, symbolName) {
      const urlDoc = toUrl(doc, element, url).toString();
      const urlCopy = new URL(urlDoc);
      urlCopy.hash = "";
      urlCopy.search = "";
      const importURL = urlCopy.href;
      const mod = moduleCache.get(importURL);
      if (mod) {
        return mod[symbolName];
      }
      return import(
        /* @vite-ignore */
        importURL
      ).then((mod2) => {
        moduleCache.set(importURL, mod2);
        return mod2[symbolName];
      });
    },
    raf: (fn) => {
      return new Promise((resolve) => {
        requestAnimationFrame(() => {
          resolve(fn());
        });
      });
    },
    nextTick: (fn) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(fn());
        });
      });
    },
    chunkForSymbol() {
      return void 0;
    }
  };
};
function toUrl(doc, element, url) {
  var _a;
  const containerEl = getContainer(element);
  const base = new URL((_a = containerEl === null || containerEl === void 0 ? void 0 : containerEl.getAttribute("q:base")) !== null && _a !== void 0 ? _a : doc.baseURI, doc.baseURI);
  return new URL(url, base);
}
var setPlatform = (doc, plt) => doc[DocumentPlatform] = plt;
var getPlatform = (docOrNode) => {
  const doc = getDocument(docOrNode);
  return doc[DocumentPlatform] || (doc[DocumentPlatform] = createPlatform(doc));
};
var DocumentPlatform = Symbol();
function useHostElement() {
  const element = getInvokeContext().hostElement;
  assertDefined(element);
  return element;
}
function isHtmlElement(node) {
  return node ? node.nodeType === NodeType.ELEMENT_NODE : false;
}
var NodeType;
(function(NodeType2) {
  NodeType2[NodeType2["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
  NodeType2[NodeType2["ATTRIBUTE_NODE"] = 2] = "ATTRIBUTE_NODE";
  NodeType2[NodeType2["TEXT_NODE"] = 3] = "TEXT_NODE";
  NodeType2[NodeType2["CDATA_SECTION_NODE"] = 4] = "CDATA_SECTION_NODE";
  NodeType2[NodeType2["PROCESSING_INSTRUCTION_NODE"] = 7] = "PROCESSING_INSTRUCTION_NODE";
  NodeType2[NodeType2["COMMENT_NODE"] = 8] = "COMMENT_NODE";
  NodeType2[NodeType2["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
  NodeType2[NodeType2["DOCUMENT_TYPE_NODE"] = 10] = "DOCUMENT_TYPE_NODE";
  NodeType2[NodeType2["DOCUMENT_FRAGMENT_NODE"] = 11] = "DOCUMENT_FRAGMENT_NODE";
})(NodeType || (NodeType = {}));
function stringifyDebug(value) {
  if (value == null)
    return String(value);
  if (typeof value === "function")
    return value.name;
  if (isHtmlElement(value))
    return stringifyElement(value);
  if (value instanceof URL)
    return String(value);
  if (typeof value === "object")
    return JSON.stringify(value, function(key, value2) {
      if (isHtmlElement(value2))
        return stringifyElement(value2);
      return value2;
    });
  return String(value);
}
function stringifyElement(element) {
  let html = "<" + element.localName;
  const attributes = element.attributes;
  const names = [];
  for (let i = 0; i < attributes.length; i++) {
    names.push(attributes[i].name);
  }
  names.sort();
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    let value = element.getAttribute(name);
    if (value === null || value === void 0 ? void 0 : value.startsWith("file:/")) {
      value = value.replace(/(file:\/\/).*(\/.*)$/, (all, protocol, file) => protocol + "..." + file);
    }
    html += " " + name + (value == null || value == "" ? "" : "='" + value.replace("'", "&apos;") + "'");
  }
  return html + ">";
}
var QError;
(function(QError2) {
  QError2[QError2["TODO"] = 0] = "TODO";
  QError2[QError2["Core_qConfigNotFound_path"] = 1] = "Core_qConfigNotFound_path";
  QError2[QError2["Core_unrecognizedStack_frame"] = 2] = "Core_unrecognizedStack_frame";
  QError2[QError2["Core_noAttribute_atr1_element"] = 3] = "Core_noAttribute_atr1_element";
  QError2[QError2["Core_noAttribute_atr1_attr2_element"] = 4] = "Core_noAttribute_atr1_attr2_element";
  QError2[QError2["Core_missingProperty_name_props"] = 5] = "Core_missingProperty_name_props";
  QError2[QError2["Core_missingExport_name_url_props"] = 6] = "Core_missingExport_name_url_props";
  QError2[QError2["QRL_expectFunction_url_actual"] = 100] = "QRL_expectFunction_url_actual";
  QError2[QError2["Injector_noHost_element"] = 200] = "Injector_noHost_element";
  QError2[QError2["Injector_expectedSpecificInjector_expected_actual"] = 201] = "Injector_expectedSpecificInjector_expected_actual";
  QError2[QError2["Injector_notElement_arg"] = 202] = "Injector_notElement_arg";
  QError2[QError2["Injector_wrongMethodThis_expected_actual"] = 203] = "Injector_wrongMethodThis_expected_actual";
  QError2[QError2["Injector_missingSerializedState_entityKey_element"] = 204] = "Injector_missingSerializedState_entityKey_element";
  QError2[QError2["Injector_notFound_element"] = 206] = "Injector_notFound_element";
  QError2[QError2["Injector_eventInjectorNotSerializable"] = 207] = "Injector_eventInjectorNotSerializable";
  QError2[QError2["Entity_notValidKey_key"] = 300] = "Entity_notValidKey_key";
  QError2[QError2["Entity_keyAlreadyExists_key"] = 301] = "Entity_keyAlreadyExists_key";
  QError2[QError2["Entity_invalidAttribute_name"] = 303] = "Entity_invalidAttribute_name";
  QError2[QError2["Entity_missingExpandoOrState_attrName"] = 304] = "Entity_missingExpandoOrState_attrName";
  QError2[QError2["Entity_elementMissingEntityAttr_element_attr"] = 305] = "Entity_elementMissingEntityAttr_element_attr";
  QError2[QError2["Entity_noState_entity_props"] = 306] = "Entity_noState_entity_props";
  QError2[QError2["Entity_expected_obj"] = 307] = "Entity_expected_obj";
  QError2[QError2["Entity_overridesConstructor_entity"] = 308] = "Entity_overridesConstructor_entity";
  QError2[QError2["Entity_keyMissingParts_key_key"] = 309] = "Entity_keyMissingParts_key_key";
  QError2[QError2["Entity_no$type_entity"] = 310] = "Entity_no$type_entity";
  QError2[QError2["Entity_no$keyProps_entity"] = 311] = "Entity_no$keyProps_entity";
  QError2[QError2["Entity_no$qrl_entity"] = 312] = "Entity_no$qrl_entity";
  QError2[QError2["Entity_nameCollision_name_currentQrl_expectedQrl"] = 313] = "Entity_nameCollision_name_currentQrl_expectedQrl";
  QError2[QError2["Entity_keyTooManyParts_entity_parts_key"] = 314] = "Entity_keyTooManyParts_entity_parts_key";
  QError2[QError2["Entity_keyNameMismatch_key_name_entity_name"] = 315] = "Entity_keyNameMismatch_key_name_entity_name";
  QError2[QError2["Entity_stateMissingKey_state"] = 316] = "Entity_stateMissingKey_state";
  QError2[QError2["Component_bindNeedsKey"] = 400] = "Component_bindNeedsKey";
  QError2[QError2["Component_bindNeedsValue"] = 401] = "Component_bindNeedsValue";
  QError2[QError2["Component_needsState"] = 402] = "Component_needsState";
  QError2[QError2["Component_needsInjectionContext_constructor"] = 403] = "Component_needsInjectionContext_constructor";
  QError2[QError2["Component_noProperty_propName_props_host"] = 404] = "Component_noProperty_propName_props_host";
  QError2[QError2["Component_notFound_component"] = 405] = "Component_notFound_component";
  QError2[QError2["Component_doesNotMatch_component_actual"] = 406] = "Component_doesNotMatch_component_actual";
  QError2[QError2["Component_noState_component_props"] = 408] = "Component_noState_component_props";
  QError2[QError2["Provider_unrecognizedFormat_value"] = 500] = "Provider_unrecognizedFormat_value";
  QError2[QError2["Render_unexpectedJSXNodeType_type"] = 600] = "Render_unexpectedJSXNodeType_type";
  QError2[QError2["Render_unsupportedFormat_obj_attr"] = 601] = "Render_unsupportedFormat_obj_attr";
  QError2[QError2["Render_expectingEntity_entity"] = 602] = "Render_expectingEntity_entity";
  QError2[QError2["Render_expectingEntityArray_obj"] = 603] = "Render_expectingEntityArray_obj";
  QError2[QError2["Render_expectingEntityOrComponent_obj"] = 604] = "Render_expectingEntityOrComponent_obj";
  QError2[QError2["Render_stateMachineStuck"] = 699] = "Render_stateMachineStuck";
  QError2[QError2["Event_emitEventRequiresName_url"] = 700] = "Event_emitEventRequiresName_url";
  QError2[QError2["Event_emitEventCouldNotFindListener_event_element"] = 701] = "Event_emitEventCouldNotFindListener_event_element";
})(QError || (QError = {}));
function qError(code, ...args) {
  if (qDev) {
    const text = codeToText(code);
    const parts = text.split("{}");
    const error = parts.map((value, index) => {
      return value + (index === parts.length - 1 ? "" : stringifyDebug(args[index]));
    }).join("");
    debugger;
    return new Error(error);
  } else {
    return new Error(`QError ` + code);
  }
}
function codeToText(code) {
  const area = {
    0: "ERROR",
    1: "QRL-ERROR",
    2: "INJECTOR-ERROR",
    3: "SERVICE-ERROR",
    4: "COMPONENT-ERROR",
    5: "PROVIDER-ERROR",
    6: "RENDER-ERROR",
    7: "EVENT-ERROR"
  }[Math.floor(code / 100)];
  const text = {
    [QError.TODO]: "{}",
    [QError.Core_qConfigNotFound_path]: "QConfig not found in path '{}'.",
    [QError.Core_unrecognizedStack_frame]: "Unrecognized stack format '{}'",
    [QError.Core_noAttribute_atr1_element]: "Could not find entity state '{}' at '{}' or any of it's parents.",
    [QError.Core_noAttribute_atr1_attr2_element]: "Could not find entity state '{}' ( or entity provider '{}') at '{}' or any of it's parents.",
    [QError.Core_missingProperty_name_props]: "Missing property '{}' in props '{}'.",
    [QError.Core_missingExport_name_url_props]: "Missing export '{}' from '{}'. Exported symbols are: {}",
    [QError.QRL_expectFunction_url_actual]: "QRL '${}' should point to function, was '{}'.",
    [QError.Injector_noHost_element]: "Can't find host element above '{}'.",
    [QError.Injector_expectedSpecificInjector_expected_actual]: "Provider is expecting '{}' but got '{}'.",
    [QError.Injector_notElement_arg]: "Expected 'Element' was '{}'.",
    [QError.Injector_wrongMethodThis_expected_actual]: "Expected injection 'this' to be of type '{}', but was of type '{}'.",
    [QError.Injector_missingSerializedState_entityKey_element]: "Entity key '{}' is found on '{}' but does not contain state. Was 'serializeState()' not run during dehydration?",
    [QError.Injector_notFound_element]: "No injector can be found starting at '{}'.",
    [QError.Injector_eventInjectorNotSerializable]: "EventInjector does not support serialization.",
    [QError.Entity_notValidKey_key]: "Data key '{}' is not a valid key.\n  - Data key can only contain characters (preferably lowercase) or number\n  - Data key is prefixed with entity name\n  - Data key is made up from parts that are separated with ':'.",
    [QError.Entity_keyAlreadyExists_key]: "A entity with key '{}' already exists.",
    [QError.Entity_invalidAttribute_name]: "'{}' is not a valid attribute. Attributes can only contain 'a-z' (lowercase), '0-9', '-' and '_'.",
    [QError.Entity_missingExpandoOrState_attrName]: "Found '{}' but expando did not have entity and attribute did not have state.",
    [QError.Entity_elementMissingEntityAttr_element_attr]: "Element '{}' is missing entity attribute definition '{}'.",
    [QError.Entity_noState_entity_props]: "Unable to create state for entity '{}' with props '{}' because no state found and '$newState()' method was not defined on entity.",
    [QError.Entity_expected_obj]: "'{}' is not an instance of 'Entity'.",
    [QError.Entity_overridesConstructor_entity]: "'{}' overrides 'constructor' property preventing 'EntityType' retrieval.",
    [QError.Entity_no$keyProps_entity]: "Entity '{}' does not define '$keyProps'.",
    [QError.Entity_no$type_entity]: "Entity '{}' must have static '$type' property defining the name of the entity.",
    [QError.Entity_no$qrl_entity]: "Entity '{}' must have static '$qrl' property defining the import location of the entity.",
    [QError.Entity_nameCollision_name_currentQrl_expectedQrl]: "Name collision. Already have entity named '{}' with QRL '{}' but expected QRL '{}'.",
    [QError.Entity_keyMissingParts_key_key]: "Entity key '{}' is missing values. Expecting '{}:someValue'.",
    [QError.Entity_keyTooManyParts_entity_parts_key]: "Entity '{}' defines '$keyProps' as  '{}'. Actual key '{}' has more parts than entity defines.",
    [QError.Entity_keyNameMismatch_key_name_entity_name]: "Key '{}' belongs to entity named '{}', but expected entity '{}' with name '{}'.",
    [QError.Entity_stateMissingKey_state]: "Entity state is missing '$key'. Are you sure you passed in state? Got '{}'.",
    [QError.Component_bindNeedsKey]: `'bind:' must have an key. (Example: 'bind:key="propertyName"').`,
    [QError.Component_bindNeedsValue]: `'bind:id' must have a property name. (Example: 'bind:key="propertyName"').`,
    [QError.Component_needsState]: "Can't find state on host element.",
    [QError.Component_needsInjectionContext_constructor]: "Components must be instantiated inside an injection context. Use '{}.new(...)' for creation.",
    [QError.Component_noProperty_propName_props_host]: "Property '{}' not found in '{}' on component '{}'.",
    [QError.Component_notFound_component]: "Unable to find '{}' component.",
    [QError.Component_doesNotMatch_component_actual]: "Requesting component type '{}' does not match existing component instance '{}'.",
    [QError.Component_noState_component_props]: "Unable to create state for component '{}' with props '{}' because no state found and '$newState()' method was not defined on component.",
    [QError.Provider_unrecognizedFormat_value]: "Unrecognized expression format '{}'.",
    [QError.Render_unexpectedJSXNodeType_type]: "Unexpected JSXNode<{}> type.",
    [QError.Render_unsupportedFormat_obj_attr]: "Value '{}' can't be written into '{}' attribute.",
    [QError.Render_expectingEntity_entity]: "Expecting entity object, got '{}'.",
    [QError.Render_expectingEntityArray_obj]: "Expecting array of entities, got '{}'.",
    [QError.Render_expectingEntityOrComponent_obj]: "Expecting Entity or Component got '{}'.",
    [QError.Render_stateMachineStuck]: "Render state machine did not advance.",
    [QError.Event_emitEventRequiresName_url]: "Missing '$type' attribute in the '{}' url.",
    [QError.Event_emitEventCouldNotFindListener_event_element]: "Re-emitting event '{}' but no listener found at '{}' or any of its parents."
  }[code];
  let textCode = "000" + code;
  textCode = textCode.slice(-3);
  return `${area}(Q-${textCode}): ${text}`;
}
function isNode$1(value) {
  return value && typeof value.nodeType == "number";
}
function isDocument(value) {
  return value && value.nodeType == NodeType.DOCUMENT_NODE;
}
function isElement(value) {
  return isNode$1(value) && value.nodeType == NodeType.ELEMENT_NODE;
}
var UNDEFINED_PREFIX = "";
var QRL_PREFIX = "";
function resume(elmOrDoc) {
  const parentElm = isDocument(elmOrDoc) ? elmOrDoc.documentElement : elmOrDoc;
  if (!isContainer(parentElm)) {
    return;
  }
  const doc = getDocument(elmOrDoc);
  const isDoc = isDocument(elmOrDoc) || elmOrDoc === doc.documentElement;
  const parentJSON = isDoc ? doc.body : parentElm;
  const script = getQwikJSON(parentJSON);
  if (!script) {
    logWarn("Skipping hydration qwik/json metadata was not found.");
    return;
  }
  script.remove();
  const map = getProxyMap(doc);
  const meta = JSON.parse(script.textContent || "{}");
  const elements = /* @__PURE__ */ new Map();
  getNodesInScope(parentElm, hasQId).forEach((el) => {
    const id = el.getAttribute(ELEMENT_ID);
    elements.set(ELEMENT_ID_PREFIX + id, el);
  });
  const getObject = (id) => {
    return getObjectImpl(id, elements, meta.objs, map);
  };
  reviveValues(meta.objs, meta.subs, elements, map, parentJSON);
  for (const obj of meta.objs) {
    reviveNestedObjects(obj, getObject);
  }
  getNodesInScope(parentElm, hasQObj).forEach((el) => {
    const qobj = el.getAttribute(QObjAttr);
    const host = el.getAttribute(QHostAttr);
    const ctx = getContext(el);
    qobj.split(" ").forEach((part) => {
      if (part !== "") {
        const obj = getObject(part);
        ctx.refMap.add(obj);
      } else if (qDev) {
        logError("QObj contains empty ref");
      }
    });
    if (host) {
      const [props, renderQrl] = host.split(" ").map(strToInt);
      assertDefined(props);
      assertDefined(renderQrl);
      ctx.props = ctx.refMap.get(props);
      ctx.renderQrl = ctx.refMap.get(renderQrl);
    }
  });
}
function snapshotState(elmOrDoc) {
  const doc = getDocument(elmOrDoc);
  const parentElm = isDocument(elmOrDoc) ? elmOrDoc.documentElement : elmOrDoc;
  const proxyMap = getProxyMap(doc);
  const objSet = /* @__PURE__ */ new Set();
  const platform = getPlatform(doc);
  const elementToIndex = /* @__PURE__ */ new Map();
  const elements = getNodesInScope(parentElm, hasQObj);
  elements.forEach((node) => {
    const props = getContext(node);
    const qMap = props.refMap;
    qMap.array.forEach((v) => {
      collectValue(v, objSet);
    });
  });
  const objs = Array.from(objSet);
  objs.sort((a, b) => {
    const isProxyA = proxyMap.has(a) ? 0 : 1;
    const isProxyB = proxyMap.has(b) ? 0 : 1;
    return isProxyA - isProxyB;
  });
  const objToId = /* @__PURE__ */ new Map();
  let count = 0;
  for (const obj of objs) {
    objToId.set(obj, count);
    count++;
  }
  function getElementID(el) {
    let id = elementToIndex.get(el);
    if (id === void 0) {
      if (el.isConnected) {
        id = intToStr(elementToIndex.size);
        el.setAttribute(ELEMENT_ID, id);
        id = ELEMENT_ID_PREFIX + id;
      } else {
        id = null;
      }
      elementToIndex.set(el, id);
    }
    return id;
  }
  function getObjId(obj) {
    if (obj !== null && typeof obj === "object") {
      const target = obj[QOjectTargetSymbol];
      const id = objToId.get(normalizeObj(target !== null && target !== void 0 ? target : obj));
      if (id !== void 0) {
        const proxySuffix = target ? "!" : "";
        return intToStr(id) + proxySuffix;
      }
      if (!target && isElement(obj)) {
        return getElementID(obj);
      }
    } else {
      const id = objToId.get(normalizeObj(obj));
      if (id !== void 0) {
        return intToStr(id);
      }
    }
    return null;
  }
  const subs = objs.map((obj) => {
    var _a;
    const subs2 = (_a = proxyMap.get(obj)) === null || _a === void 0 ? void 0 : _a[QOjectSubsSymbol];
    if (subs2) {
      return Object.fromEntries(Array.from(subs2.entries()).map(([el, set]) => {
        const id = getElementID(el);
        if (id !== null) {
          return [id, Array.from(set)];
        } else {
          return [void 0, void 0];
        }
      }));
    } else {
      return null;
    }
  }).filter((a) => !!a);
  const serialize = (value) => {
    var _a;
    return (_a = getObjId(value)) !== null && _a !== void 0 ? _a : value;
  };
  const qrlSerializeOptions = {
    platform,
    getObjId
  };
  const convertedObjs = objs.map((obj) => {
    if (Array.isArray(obj)) {
      return obj.map(serialize);
    } else if (obj && typeof obj === "object") {
      if (isQrl(obj)) {
        return QRL_PREFIX + stringifyQRL(obj, qrlSerializeOptions);
      }
      const output = {};
      Object.entries(obj).forEach(([key, value]) => {
        output[key] = serialize(value);
      });
      return output;
    }
    return obj;
  });
  elements.forEach((node) => {
    const ctx = getContext(node);
    const props = ctx.props;
    const renderQrl = ctx.renderQrl;
    const attribute = ctx.refMap.array.map((obj) => {
      const id = getObjId(obj);
      assertDefined(id);
      return id;
    }).join(" ");
    node.setAttribute(QObjAttr, attribute);
    if (props) {
      const objs2 = [props];
      if (renderQrl) {
        objs2.push(renderQrl);
      }
      node.setAttribute(QHostAttr, objs2.map((obj) => ctx.refMap.indexOf(obj)).join(" "));
    }
  });
  if (qDev) {
    elementToIndex.forEach((value, el) => {
      if (getDocument(el) !== doc) {
        logWarn("element from different document", value, el.tagName);
      }
      if (!value) {
        logWarn("unconnected element", el.tagName, "\n");
      }
    });
  }
  return {
    objs: convertedObjs,
    subs
  };
}
function getQwikJSON(parentElm) {
  let child = parentElm.lastElementChild;
  while (child) {
    if (child.tagName === "SCRIPT" && child.getAttribute("type") === "qwik/json") {
      return child;
    }
    child = child.previousElementSibling;
  }
  return void 0;
}
function getNodesInScope(parent, predicate) {
  const nodes = [];
  walkNodes(nodes, parent, predicate);
  return nodes;
}
function walkNodes(nodes, parent, predicate) {
  let child = parent.firstElementChild;
  while (child) {
    if (!isContainer(child)) {
      if (predicate(child)) {
        nodes.push(child);
      }
      walkNodes(nodes, child, predicate);
    }
    child = child.nextElementSibling;
  }
}
function reviveValues(objs, subs, elementMap, map, containerEl) {
  for (let i = 0; i < objs.length; i++) {
    const value = objs[i];
    if (typeof value === "string") {
      if (value === UNDEFINED_PREFIX) {
        objs[i] = void 0;
      } else if (value.startsWith(QRL_PREFIX)) {
        objs[i] = parseQRL(value.slice(1), containerEl);
      }
    } else {
      const sub = subs[i];
      if (sub) {
        const converted = /* @__PURE__ */ new Map();
        Object.entries(sub).forEach((entry) => {
          const el = elementMap.get(entry[0]);
          if (!el) {
            logWarn("QWIK can not revive subscriptions because of missing element ID", entry, value);
            return;
          }
          const set = new Set(entry[1]);
          converted.set(el, set);
        });
        _restoreQObject(value, map, converted);
      }
    }
  }
}
function reviveNestedObjects(obj, getObject) {
  if (obj && typeof obj == "object") {
    if (isQrl(obj)) {
      if (obj.capture && obj.capture.length > 0) {
        obj.captureRef = obj.capture.map(getObject);
        obj.capture = null;
      }
      return;
    } else if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        const value = obj[i];
        if (typeof value == "string") {
          obj[i] = getObject(value);
        } else {
          reviveNestedObjects(value, getObject);
        }
      }
    } else if (Object.getPrototypeOf(obj) === Object.prototype) {
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          if (typeof value == "string") {
            obj[key] = getObject(value);
          } else {
            reviveNestedObjects(value, getObject);
          }
        }
      }
    }
  }
}
function getObjectImpl(id, elements, objs, map) {
  if (id.startsWith(ELEMENT_ID_PREFIX)) {
    assertEqual(elements.has(id), true);
    return elements.get(id);
  }
  const index = strToInt(id);
  assertEqual(objs.length > index, true);
  const obj = objs[index];
  const needsProxy = id.endsWith("!");
  if (needsProxy) {
    const finalObj = map.get(obj);
    assertDefined(finalObj);
    return finalObj;
  }
  return obj;
}
function normalizeObj(obj) {
  var _a;
  if (obj === void 0 || !shouldSerialize(obj)) {
    return UNDEFINED_PREFIX;
  }
  if (obj && typeof obj === "object") {
    const value = (_a = obj[QOjectTargetSymbol]) !== null && _a !== void 0 ? _a : obj;
    return value;
  }
  return obj;
}
function collectValue(obj, seen) {
  collectQObjects(obj, seen);
  seen.add(normalizeObj(obj));
}
function collectQrl(obj, seen) {
  seen.add(normalizeObj(obj));
  if (obj.captureRef) {
    obj.captureRef.forEach((obj2) => collectValue(obj2, seen));
  }
}
function collectQObjects(obj, seen) {
  if (obj != null) {
    if (typeof obj === "object") {
      if (!obj[QOjectTargetSymbol] && isElement(obj)) {
        return;
      }
      if (isQrl(obj)) {
        collectQrl(obj, seen);
        return;
      }
      obj = normalizeObj(obj);
    }
    if (typeof obj === "object") {
      if (seen.has(obj))
        return;
      seen.add(obj);
      if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          collectQObjects(obj[i], seen);
        }
      } else {
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            collectQObjects(obj[key], seen);
          }
        }
      }
    }
    if (typeof obj === "string") {
      seen.add(obj);
    }
  }
}
function isContainer(el) {
  return el.hasAttribute(QContainerAttr);
}
function hasQObj(el) {
  return el.hasAttribute(QObjAttr);
}
function hasQId(el) {
  return el.hasAttribute(ELEMENT_ID);
}
var intToStr = (nu) => {
  return nu.toString(36);
};
var strToInt = (nu) => {
  return parseInt(nu, 36);
};
function newQObjectMap(element) {
  const array = [];
  let added = element.hasAttribute(QObjAttr);
  return {
    array,
    get(index) {
      return array[index];
    },
    indexOf(obj) {
      const index = array.indexOf(obj);
      return index === -1 ? void 0 : index;
    },
    add(object) {
      const index = array.indexOf(object);
      if (index === -1) {
        array.push(object);
        if (!added) {
          element.setAttribute(QObjAttr, "");
          added = true;
        }
        return array.length - 1;
      }
      return index;
    }
  };
}
function qDeflate(obj, hostCtx) {
  return String(hostCtx.refMap.add(obj));
}
function qInflate(ref, hostCtx) {
  const int = parseInt(ref, 10);
  const obj = hostCtx.refMap.get(int);
  assertEqual(hostCtx.refMap.array.length > int, true);
  return obj;
}
function fromCamelToKebabCase(text) {
  return text.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function debugStringify(value) {
  if (value != null && typeof value == "object") {
    return String(value.constructor.name) + "\n" + safeJSONStringify(value);
  }
  return String(value);
}
function safeJSONStringify(value) {
  try {
    return JSON.stringify(value, null, "  ");
  } catch (e) {
    return String(e);
  }
}
var ON_PROP_REGEX = /^on([A-Z]|-.).*Qrl$/;
var ON$_PROP_REGEX = /^on([A-Z]|-.).*\$$/;
function isOnProp(prop) {
  return ON_PROP_REGEX.test(prop);
}
function isOn$Prop(prop) {
  return ON$_PROP_REGEX.test(prop);
}
function qPropWriteQRL(rctx, ctx, prop, value) {
  if (!value) {
    return;
  }
  if (typeof value == "string") {
    value = parseQRL(value, ctx.element);
  }
  const existingQRLs = getExistingQRLs(ctx, prop);
  if (Array.isArray(value)) {
    value.forEach((value2) => qPropWriteQRL(rctx, ctx, prop, value2));
  } else if (isQrl(value)) {
    const cp = value.copy();
    cp.setContainer(ctx.element);
    const capture = cp.capture;
    if (capture == null) {
      const captureRef = cp.captureRef;
      cp.capture = captureRef && captureRef.length ? captureRef.map((ref) => qDeflate(ref, ctx)) : EMPTY_ARRAY;
    }
    for (let i = 0; i < existingQRLs.length; i++) {
      const qrl2 = existingQRLs[i];
      if (!isPromise(qrl2) && qrl2.canonicalChunk === cp.canonicalChunk && qrl2.symbol === cp.symbol) {
        existingQRLs.splice(i, 1);
        i--;
      }
    }
    existingQRLs.push(cp);
  } else if (isPromise(value)) {
    const writePromise = value.then((qrl2) => {
      existingQRLs.splice(existingQRLs.indexOf(writePromise), 1);
      qPropWriteQRL(rctx, ctx, prop, qrl2);
      return qrl2;
    });
    existingQRLs.push(writePromise);
  } else {
    throw qError(QError.TODO, `Not QRLInternal: prop: ${prop}; value: ` + value);
  }
  const kebabProp = fromCamelToKebabCase(prop);
  const newValue = serializeQRLs(existingQRLs, ctx);
  if (ctx.element.getAttribute(kebabProp) !== newValue) {
    if (rctx) {
      setAttribute(rctx, ctx.element, kebabProp, newValue);
    } else {
      ctx.element.setAttribute(kebabProp, newValue);
    }
  }
}
function getExistingQRLs(ctx, prop) {
  const key = "event:" + prop;
  let parts = ctx.cache.get(key);
  if (!parts) {
    const attrName = fromCamelToKebabCase(prop);
    parts = [];
    (ctx.element.getAttribute(attrName) || "").split("\n").forEach((qrl2) => {
      if (qrl2) {
        parts.push(parseQRL(qrl2, ctx.element));
      }
    });
    ctx.cache.set(key, parts);
  }
  return parts;
}
function serializeQRLs(existingQRLs, ctx) {
  const platform = getPlatform(getDocument(ctx.element));
  const element = ctx.element;
  const opts = {
    platform,
    element
  };
  return existingQRLs.map((qrl2) => isPromise(qrl2) ? "" : stringifyQRL(qrl2, opts)).filter((v) => !!v).join("\n");
}
Error.stackTraceLimit = 9999;
var Q_IS_RESUMED = "__isResumed__";
var Q_CTX = "__ctx__";
function resumeIfNeeded(containerEl) {
  const isHydrated = containerEl[Q_IS_RESUMED];
  if (!isHydrated) {
    containerEl[Q_IS_RESUMED] = true;
    resume(containerEl);
  }
}
function getContext(element) {
  let ctx = element[Q_CTX];
  if (!ctx) {
    const cache = /* @__PURE__ */ new Map();
    element[Q_CTX] = ctx = {
      element,
      cache,
      refMap: newQObjectMap(element),
      dirty: false,
      props: void 0,
      renderQrl: void 0,
      component: void 0
    };
  }
  return ctx;
}
var PREFIXES = ["onWindow", "onWindow", "on"];
function normalizeOnProp(prop) {
  let scope = "on";
  for (const prefix of PREFIXES) {
    if (prop.startsWith(prefix)) {
      scope = prefix;
      prop = prop.slice(prefix.length);
    }
  }
  if (prop.startsWith("-")) {
    prop = prop.slice(1);
  } else {
    prop = prop.toLowerCase();
  }
  return `${scope}:${prop}`;
}
function setEvent(rctx, ctx, prop, value) {
  qPropWriteQRL(rctx, ctx, normalizeOnProp(prop), value);
}
function getProps(ctx) {
  if (!ctx.props) {
    ctx.props = readWriteProxy({}, getProxyMap(getDocument(ctx.element)));
    ctx.refMap.add(ctx.props);
  }
  return ctx.props;
}
var Host = { __brand__: "host" };
var SkipRerender = { __brand__: "skip" };
function $(expression) {
  return runtimeQrl(expression);
}
function implicit$FirstArg(fn) {
  return function(first, ...rest) {
    return fn.call(null, $(first), ...rest);
  };
}
function visitJsxNode(ctx, elm, jsxNode, isSvg) {
  if (jsxNode === void 0) {
    return smartUpdateChildren(ctx, elm, [], "root", isSvg);
  }
  if (Array.isArray(jsxNode)) {
    return smartUpdateChildren(ctx, elm, jsxNode.flat(), "root", isSvg);
  } else if (jsxNode.type === Host) {
    updateProperties(ctx, getContext(elm), jsxNode.props, isSvg);
    return smartUpdateChildren(ctx, elm, jsxNode.children || [], "root", isSvg);
  } else {
    return smartUpdateChildren(ctx, elm, [jsxNode], "root", isSvg);
  }
}
function hashCode(text, hash = 0) {
  if (text.length === 0)
    return hash;
  for (let i = 0; i < text.length; i++) {
    const chr = text.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return Number(Math.abs(hash)).toString(36);
}
function styleKey(qStyles) {
  return qStyles && String(hashCode(qStyles.symbol));
}
function styleHost(styleId) {
  return styleId && ComponentStylesPrefixHost + styleId;
}
function styleContent(styleId) {
  return styleId && ComponentStylesPrefixContent + styleId;
}
function jsx(type, props, key) {
  return new JSXNodeImpl(type, props, key);
}
var JSXNodeImpl = class {
  constructor(type, props, key = null) {
    this.type = type;
    this.props = props;
    this.children = EMPTY_ARRAY;
    this.text = void 0;
    this.key = null;
    if (key != null) {
      this.key = String(key);
    }
    if (props) {
      const children = processNode(props.children);
      if (children !== void 0) {
        if (Array.isArray(children)) {
          this.children = children;
        } else {
          this.children = [children];
        }
      }
    }
  }
};
function processNode(node) {
  if (node == null || typeof node === "boolean") {
    return void 0;
  }
  if (isJSXNode(node)) {
    if (node.type === Host || node.type === SkipRerender) {
      return node;
    } else if (typeof node.type === "function") {
      return processNode(node.type(Object.assign(Object.assign({}, node.props), { children: node.children }), node.key));
    } else {
      return node;
    }
  } else if (Array.isArray(node)) {
    return node.flatMap(processNode).filter((e) => e != null);
  } else if (typeof node === "string" || typeof node === "number" || typeof node === "boolean") {
    const newNode = new JSXNodeImpl("#text", null, null);
    newNode.text = String(node);
    return newNode;
  } else {
    logWarn("Unvalid node, skipping");
    return void 0;
  }
}
var isJSXNode = (n) => {
  if (qDev) {
    if (n instanceof JSXNodeImpl) {
      return true;
    }
    if (n && typeof n === "object" && n.constructor.name === JSXNodeImpl.name) {
      throw new Error(`Duplicate implementations of "JSXNodeImpl" found`);
    }
    return false;
  } else {
    return n instanceof JSXNodeImpl;
  }
};
var Fragment = (props) => props.children;
var firstRenderComponent = (rctx, ctx) => {
  ctx.element.setAttribute(QHostAttr, "");
  const result = renderComponent(rctx, ctx);
  return result;
};
var renderComponent = (rctx, ctx) => {
  const hostElement = ctx.element;
  const onRenderQRL = ctx.renderQrl;
  assertDefined(onRenderQRL);
  const onRenderFn = onRenderQRL.invokeFn();
  ctx.dirty = false;
  rctx.globalState.hostsStaging.delete(hostElement);
  const invocatinContext = newInvokeContext(rctx.doc, hostElement, hostElement, "qRender");
  invocatinContext.qrl = onRenderQRL;
  const promise = useInvoke(invocatinContext, onRenderFn);
  return then(promise, (jsxNode) => {
    var _a;
    rctx.hostElements.add(hostElement);
    let componentCtx = ctx.component;
    if (!componentCtx) {
      componentCtx = ctx.component = {
        hostElement,
        slots: [],
        styleHostClass: void 0,
        styleClass: void 0,
        styleId: void 0
      };
      const scopedStyleId = (_a = hostElement.getAttribute(ComponentScopedStyles)) !== null && _a !== void 0 ? _a : void 0;
      if (scopedStyleId) {
        componentCtx.styleId = scopedStyleId;
        componentCtx.styleHostClass = styleHost(scopedStyleId);
        componentCtx.styleClass = styleContent(scopedStyleId);
        hostElement.classList.add(componentCtx.styleHostClass);
      }
    }
    componentCtx.slots = [];
    const newCtx = Object.assign(Object.assign({}, rctx), { component: componentCtx });
    return visitJsxNode(newCtx, hostElement, processNode(jsxNode), false);
  });
};
var SVG_NS = "http://www.w3.org/2000/svg";
function smartUpdateChildren(ctx, elm, ch, mode, isSvg) {
  if (ch.length === 1 && ch[0].type === SkipRerender) {
    if (elm.firstChild !== null) {
      return;
    }
    ch = ch[0].children;
  }
  const oldCh = getChildren(elm, mode);
  if (oldCh.length > 0 && ch.length > 0) {
    return updateChildren(ctx, elm, oldCh, ch, isSvg);
  } else if (ch.length > 0) {
    return addVnodes(ctx, elm, void 0, ch, 0, ch.length - 1, isSvg);
  } else if (oldCh.length > 0) {
    return removeVnodes(ctx, elm, oldCh, 0, oldCh.length - 1);
  }
}
function updateChildren(ctx, parentElm, oldCh, newCh, isSvg) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx;
  let idxInOld;
  let elmToMove;
  const results = [];
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      results.push(patchVnode(ctx, oldStartVnode, newStartVnode, isSvg));
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      results.push(patchVnode(ctx, oldEndVnode, newEndVnode, isSvg));
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      results.push(patchVnode(ctx, oldStartVnode, newEndVnode, isSvg));
      insertBefore(ctx, parentElm, oldStartVnode, oldEndVnode.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      results.push(patchVnode(ctx, oldEndVnode, newStartVnode, isSvg));
      insertBefore(ctx, parentElm, oldEndVnode, oldStartVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (oldKeyToIdx === void 0) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = oldKeyToIdx[newStartVnode.key];
      if (idxInOld === void 0) {
        const newElm = createElm(ctx, newStartVnode, isSvg);
        results.push(then(newElm, (newElm2) => {
          insertBefore(ctx, parentElm, newElm2, oldStartVnode);
        }));
      } else {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.nodeName !== newStartVnode.type) {
          const newElm = createElm(ctx, newStartVnode, isSvg);
          results.push(then(newElm, (newElm2) => {
            insertBefore(ctx, parentElm, newElm2, oldStartVnode);
          }));
        } else {
          results.push(patchVnode(ctx, elmToMove, newStartVnode, isSvg));
          oldCh[idxInOld] = void 0;
          insertBefore(ctx, parentElm, elmToMove, oldStartVnode);
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (newStartIdx <= newEndIdx) {
    const before = newCh[newEndIdx + 1] == null ? void 0 : newCh[newEndIdx + 1].elm;
    results.push(addVnodes(ctx, parentElm, before, newCh, newStartIdx, newEndIdx, isSvg));
  }
  let wait = promiseAll(results);
  if (oldStartIdx <= oldEndIdx) {
    wait = then(wait, () => {
      removeVnodes(ctx, parentElm, oldCh, oldStartIdx, oldEndIdx);
    });
  }
  return wait;
}
function isComponentNode(node) {
  return node.props && OnRenderProp in node.props;
}
function getCh(elm) {
  return Array.from(elm.childNodes).filter(isNode);
}
function getChildren(elm, mode) {
  switch (mode) {
    case "default":
      return getCh(elm);
    case "slot":
      return getCh(elm).filter(isChildSlot);
    case "root":
      return getCh(elm).filter(isChildComponent);
    case "fallback":
      return getCh(elm).filter(isFallback);
  }
}
function isNode(elm) {
  return elm.nodeType === 1 || elm.nodeType === 3;
}
function isFallback(node) {
  return node.nodeName === "Q:FALLBACK";
}
function isChildSlot(node) {
  return node.nodeName !== "Q:FALLBACK" && isChildComponent(node);
}
function isSlotTemplate(node) {
  return node.nodeName === "TEMPLATE" && node.hasAttribute(QSlotAttr);
}
function isChildComponent(node) {
  return node.nodeName !== "TEMPLATE" || !node.hasAttribute(QSlotAttr);
}
function splitBy(input, condition) {
  var _a;
  const output = {};
  for (const item of input) {
    const key = condition(item);
    const array = (_a = output[key]) !== null && _a !== void 0 ? _a : output[key] = [];
    array.push(item);
  }
  return output;
}
function patchVnode(rctx, elm, vnode, isSvg) {
  rctx.perf.visited++;
  vnode.elm = elm;
  const tag = vnode.type;
  if (tag === "#text") {
    if (elm.data !== vnode.text) {
      setProperty(rctx, elm, "data", vnode.text);
    }
    return;
  }
  if (tag === Host || tag === SkipRerender) {
    return;
  }
  if (!isSvg) {
    isSvg = tag === "svg";
  }
  let promise;
  const props = vnode.props;
  const ctx = getContext(elm);
  const dirty = updateProperties(rctx, ctx, props, isSvg);
  const isSlot = tag === "q:slot";
  if (isSvg && vnode.type === "foreignObject") {
    isSvg = false;
  } else if (isSlot) {
    rctx.component.slots.push(vnode);
  }
  const isComponent = isComponentNode(vnode);
  if (dirty) {
    promise = renderComponent(rctx, ctx);
  }
  const ch = vnode.children;
  if (isComponent) {
    return then(promise, () => {
      const slotMaps = getSlots(ctx.component, elm);
      const splittedChidren = splitBy(ch, getSlotName);
      const promises = [];
      Object.entries(slotMaps.slots).forEach(([key, slotEl]) => {
        if (slotEl && !splittedChidren[key]) {
          const oldCh = getChildren(slotEl, "slot");
          if (oldCh.length > 0) {
            removeVnodes(rctx, slotEl, oldCh, 0, oldCh.length - 1);
          }
        }
      });
      Object.entries(splittedChidren).forEach(([key, ch2]) => {
        const slotElm = getSlotElement(rctx, slotMaps, elm, key);
        promises.push(smartUpdateChildren(rctx, slotElm, ch2, "slot", isSvg));
      });
      return then(promiseAll(promises), () => {
        removeTemplates(rctx, slotMaps);
      });
    });
  }
  const setsInnerHTML = checkInnerHTML(props);
  if (setsInnerHTML) {
    if (qDev && ch.length > 0) {
      logWarn("Node can not have children when innerHTML is set");
    }
    return;
  }
  return then(promise, () => {
    const mode = isSlot ? "fallback" : "default";
    return smartUpdateChildren(rctx, elm, ch, mode, isSvg);
  });
}
function addVnodes(ctx, parentElm, before, vnodes, startIdx, endIdx, isSvg) {
  const promises = [];
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx];
    assertDefined(ch);
    promises.push(createElm(ctx, ch, isSvg));
  }
  return then(promiseAll(promises), (children) => {
    for (const child of children) {
      insertBefore(ctx, parentElm, child, before);
    }
  });
}
function removeVnodes(ctx, parentElm, nodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = nodes[startIdx];
    assertDefined(ch);
    removeNode(ctx, ch);
  }
}
var refCount = 0;
var RefSymbol = Symbol();
function setSlotRef(ctx, hostElm, slotEl) {
  var _a;
  let ref = (_a = hostElm[RefSymbol]) !== null && _a !== void 0 ? _a : hostElm.getAttribute("q:sref");
  if (ref === null) {
    ref = intToStr(refCount++);
    hostElm[RefSymbol] = ref;
    setAttribute(ctx, hostElm, "q:sref", ref);
  }
  slotEl.setAttribute("q:sref", ref);
}
function getSlotElement(ctx, slotMaps, parentEl, slotName) {
  const slotEl = slotMaps.slots[slotName];
  if (slotEl) {
    return slotEl;
  }
  const templateEl = slotMaps.templates[slotName];
  if (templateEl) {
    return templateEl.content;
  }
  const template = createTemplate(ctx, slotName);
  prepend(ctx, parentEl, template);
  slotMaps.templates[slotName] = template;
  return template.content;
}
function createTemplate(ctx, slotName) {
  const template = createElement(ctx, "template", false);
  template.setAttribute(QSlotAttr, slotName);
  return template;
}
function removeTemplates(ctx, slotMaps) {
  Object.keys(slotMaps.templates).forEach((key) => {
    const template = slotMaps.templates[key];
    if (template && slotMaps.slots[key] !== void 0) {
      removeNode(ctx, template);
      slotMaps.templates[key] = void 0;
    }
  });
}
function resolveSlotProjection(ctx, hostElm, before, after) {
  Object.entries(before.slots).forEach(([key, slotEl]) => {
    if (slotEl && !after.slots[key]) {
      const template = createTemplate(ctx, key);
      const slotChildren = getChildren(slotEl, "slot");
      template.content.append(...slotChildren);
      hostElm.insertBefore(template, hostElm.firstChild);
      ctx.operations.push({
        el: template,
        operation: "slot-to-template",
        args: slotChildren,
        fn: () => {
        }
      });
    }
  });
  Object.entries(after.slots).forEach(([key, slotEl]) => {
    if (slotEl && !before.slots[key]) {
      const template = before.templates[key];
      if (template) {
        slotEl.appendChild(template.content);
        template.remove();
        ctx.operations.push({
          el: slotEl,
          operation: "template-to-slot",
          args: [template],
          fn: () => {
          }
        });
      }
    }
  });
}
function getSlotName(node) {
  var _a, _b;
  return (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a["q:slot"]) !== null && _b !== void 0 ? _b : "";
}
function createElm(rctx, vnode, isSvg) {
  rctx.perf.visited++;
  const tag = vnode.type;
  if (tag === "#text") {
    return vnode.elm = createTextNode(rctx, vnode.text);
  }
  if (!isSvg) {
    isSvg = tag === "svg";
  }
  const props = vnode.props;
  const elm = vnode.elm = createElement(rctx, tag, isSvg);
  const isComponent = isComponentNode(vnode);
  const ctx = getContext(elm);
  setKey(elm, vnode.key);
  updateProperties(rctx, ctx, props, isSvg);
  if (isSvg && tag === "foreignObject") {
    isSvg = false;
  }
  const currentComponent = rctx.component;
  if (currentComponent) {
    const styleTag = currentComponent.styleClass;
    if (styleTag) {
      classlistAdd(rctx, elm, styleTag);
    }
    if (tag === "q:slot") {
      setSlotRef(rctx, currentComponent.hostElement, elm);
      rctx.component.slots.push(vnode);
    }
  }
  let wait;
  if (isComponent) {
    const renderQRLPromise = props[OnRenderProp](elm);
    wait = then(renderQRLPromise, (output) => {
      ctx.renderQrl = output.renderQRL;
      output.waitOn.forEach((task) => {
        if (isStyleTask(task)) {
          appendStyle(rctx, elm, task);
        }
      });
      ctx.refMap.add(output.renderQRL);
      return firstRenderComponent(rctx, ctx);
    });
  } else {
    const setsInnerHTML = checkInnerHTML(props);
    if (setsInnerHTML) {
      if (qDev && vnode.children.length > 0) {
        logWarn("Node can not have children when innerHTML is set");
      }
      return elm;
    }
  }
  return then(wait, () => {
    let children = vnode.children;
    if (children.length > 0) {
      if (children.length === 1 && children[0].type === SkipRerender) {
        children = children[0].children;
      }
      const slotMap = isComponent ? getSlots(ctx.component, elm) : void 0;
      const promises = children.map((ch) => createElm(rctx, ch, isSvg));
      return then(promiseAll(promises), () => {
        let parent = elm;
        for (const node of children) {
          if (slotMap) {
            parent = getSlotElement(rctx, slotMap, elm, getSlotName(node));
          }
          parent.appendChild(node.elm);
        }
        return elm;
      });
    }
    return elm;
  });
}
var getSlots = (componentCtx, hostElm) => {
  var _a, _b, _c, _d, _e;
  const slots = {};
  const templates = {};
  const slotRef = hostElm.getAttribute("q:sref");
  const existingSlots = Array.from(hostElm.querySelectorAll(`q\\:slot[q\\:sref="${slotRef}"]`));
  const newSlots = (_a = componentCtx === null || componentCtx === void 0 ? void 0 : componentCtx.slots) !== null && _a !== void 0 ? _a : EMPTY_ARRAY;
  const t = Array.from(hostElm.childNodes).filter(isSlotTemplate);
  for (const elm of existingSlots) {
    slots[(_b = elm.getAttribute("name")) !== null && _b !== void 0 ? _b : ""] = elm;
  }
  for (const vnode of newSlots) {
    slots[(_d = (_c = vnode.props) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : ""] = vnode.elm;
  }
  for (const elm of t) {
    templates[(_e = elm.getAttribute("q:slot")) !== null && _e !== void 0 ? _e : ""] = elm;
  }
  return { slots, templates };
};
var handleStyle = (ctx, elm, _, newValue) => {
  setAttribute(ctx, elm, "style", stringifyClassOrStyle(newValue, false));
  return true;
};
var handleClass = (ctx, elm, _, newValue) => {
  setAttribute(ctx, elm, "class", stringifyClassOrStyle(newValue, true));
  return true;
};
var checkBeforeAssign = (ctx, elm, prop, newValue) => {
  if (prop in elm) {
    if (elm[prop] !== newValue) {
      setProperty(ctx, elm, prop, newValue);
    }
  }
  return true;
};
var dangerouslySetInnerHTML = "dangerouslySetInnerHTML";
var setInnerHTML = (ctx, elm, _, newValue) => {
  if (dangerouslySetInnerHTML in elm) {
    setProperty(ctx, elm, dangerouslySetInnerHTML, newValue);
  } else if ("innerHTML" in elm) {
    setProperty(ctx, elm, "innerHTML", newValue);
  }
  return true;
};
var PROP_HANDLER_MAP = {
  style: handleStyle,
  class: handleClass,
  className: handleClass,
  value: checkBeforeAssign,
  checked: checkBeforeAssign,
  [dangerouslySetInnerHTML]: setInnerHTML
};
var ALLOWS_PROPS = ["class", "className", "style", "id", "q:slot"];
var HOST_PREFIX = "host:";
function updateProperties(rctx, ctx, expectProps, isSvg) {
  if (!expectProps) {
    return false;
  }
  const elm = ctx.element;
  const qwikProps = OnRenderProp in expectProps ? getProps(ctx) : void 0;
  for (let key of Object.keys(expectProps)) {
    if (key === "children" || key === OnRenderProp) {
      continue;
    }
    const newValue = expectProps[key];
    const oldValue = ctx.cache.get(key);
    if (newValue === oldValue) {
      continue;
    }
    ctx.cache.set(key, newValue);
    if (key.startsWith("data-") || key.startsWith("aria-")) {
      setAttribute(rctx, elm, key, newValue);
      continue;
    }
    if (qwikProps) {
      const skipProperty = ALLOWS_PROPS.includes(key);
      const hPrefixed = key.startsWith(HOST_PREFIX);
      if (!skipProperty && !hPrefixed) {
        qwikProps[key] = newValue;
        continue;
      }
      if (hPrefixed) {
        key = key.slice(HOST_PREFIX.length);
      }
    } else if (qDev && key.startsWith(HOST_PREFIX)) {
      logWarn(`${HOST_PREFIX} prefix can not be used in non components`);
      continue;
    }
    if (isOnProp(key)) {
      setEvent(rctx, ctx, key.slice(0, -3), newValue);
      continue;
    }
    if (isOn$Prop(key)) {
      setEvent(rctx, ctx, key.slice(0, -1), $(newValue));
      continue;
    }
    const exception = PROP_HANDLER_MAP[key];
    if (exception) {
      if (exception(rctx, elm, key, newValue, oldValue)) {
        continue;
      }
    }
    if (!isSvg && key in elm) {
      setProperty(rctx, elm, key, newValue);
      continue;
    }
    setAttribute(rctx, elm, key, newValue);
  }
  return ctx.dirty;
}
function setAttribute(ctx, el, prop, value) {
  const fn = () => {
    if (value == null) {
      el.removeAttribute(prop);
    } else {
      el.setAttribute(prop, String(value));
    }
  };
  ctx.operations.push({
    el,
    operation: "set-attribute",
    args: [prop, value],
    fn
  });
}
function classlistAdd(ctx, el, hostStyleTag) {
  const fn = () => {
    el.classList.add(hostStyleTag);
  };
  ctx.operations.push({
    el,
    operation: "classlist-add",
    args: [hostStyleTag],
    fn
  });
}
function setProperty(ctx, node, key, value) {
  const fn = () => {
    try {
      node[key] = value;
    } catch (err) {
      logError("Set property", { node, key, value }, err);
    }
  };
  ctx.operations.push({
    el: node,
    operation: "set-property",
    args: [key, value],
    fn
  });
}
function createElement(ctx, expectTag, isSvg) {
  const el = isSvg ? ctx.doc.createElementNS(SVG_NS, expectTag) : ctx.doc.createElement(expectTag);
  ctx.operations.push({
    el,
    operation: "create-element",
    args: [expectTag],
    fn: () => {
    }
  });
  return el;
}
function insertBefore(ctx, parent, newChild, refChild) {
  const fn = () => {
    parent.insertBefore(newChild, refChild ? refChild : null);
  };
  ctx.operations.push({
    el: parent,
    operation: "insert-before",
    args: [newChild, refChild],
    fn
  });
  return newChild;
}
function appendStyle(ctx, hostElement, styleTask) {
  const fn = () => {
    const containerEl = ctx.containerEl;
    if (!containerEl.querySelector(`style[q\\:style="${styleTask.scope}"]`)) {
      const style = ctx.doc.createElement("style");
      const stylesParent = ctx.doc.documentElement === containerEl ? ctx.doc.head : containerEl;
      style.setAttribute("q:style", styleTask.scope);
      style.textContent = styleTask.content;
      stylesParent.insertBefore(style, containerEl.firstChild);
    }
  };
  ctx.operations.push({
    el: hostElement,
    operation: "append-style",
    args: [styleTask],
    fn
  });
}
function prepend(ctx, parent, newChild) {
  const fn = () => {
    parent.insertBefore(newChild, parent.firstChild);
  };
  ctx.operations.push({
    el: parent,
    operation: "prepend",
    args: [newChild],
    fn
  });
}
function removeNode(ctx, el) {
  const fn = () => {
    const parent = el.parentNode;
    if (parent) {
      parent.removeChild(el);
    } else if (qDev) {
      logWarn("Trying to remove component already removed", el);
    }
  };
  ctx.operations.push({
    el,
    operation: "remove",
    args: [],
    fn
  });
}
function createTextNode(ctx, text) {
  return ctx.doc.createTextNode(text);
}
function executeContextWithSlots(ctx) {
  const before = ctx.roots.map((elm) => getSlots(void 0, elm));
  executeContext(ctx);
  const after = ctx.roots.map((elm) => getSlots(void 0, elm));
  assertEqual(before.length, after.length);
  for (let i = 0; i < before.length; i++) {
    resolveSlotProjection(ctx, ctx.roots[i], before[i], after[i]);
  }
}
function executeContext(ctx) {
  for (const op of ctx.operations) {
    op.fn();
  }
}
function printRenderStats(ctx) {
  var _a;
  const byOp = {};
  for (const op of ctx.operations) {
    byOp[op.operation] = ((_a = byOp[op.operation]) !== null && _a !== void 0 ? _a : 0) + 1;
  }
  const affectedElements = Array.from(new Set(ctx.operations.map((a) => a.el)));
  const stats = {
    byOp,
    roots: ctx.roots,
    hostElements: Array.from(ctx.hostElements),
    affectedElements,
    visitedNodes: ctx.perf.visited,
    operations: ctx.operations.map((v) => [v.operation, v.el, ...v.args])
  };
  logDebug("Render stats", stats);
  return stats;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  const map = {};
  for (let i = beginIdx; i <= endIdx; ++i) {
    const child = children[i];
    if (child.nodeType == NodeType.ELEMENT_NODE) {
      const key = getKey(child);
      if (key !== void 0) {
        map[key] = i;
      }
    }
  }
  return map;
}
var KEY_SYMBOL = Symbol("vnode key");
function getKey(el) {
  let key = el[KEY_SYMBOL];
  if (key === void 0) {
    key = el[KEY_SYMBOL] = el.getAttribute("q:key");
  }
  return key;
}
function setKey(el, key) {
  if (typeof key === "string") {
    el.setAttribute("q:key", key);
  }
  el[KEY_SYMBOL] = key;
}
function sameVnode(vnode1, vnode2) {
  const isSameSel = vnode1.nodeName.toLowerCase() === vnode2.type;
  const isSameKey = vnode1.nodeType === NodeType.ELEMENT_NODE ? getKey(vnode1) === vnode2.key : true;
  return isSameSel && isSameKey;
}
function checkInnerHTML(props) {
  return props && ("innerHTML" in props || dangerouslySetInnerHTML in props);
}
function stringifyClassOrStyle(obj, isClass) {
  if (obj == null)
    return "";
  if (typeof obj == "object") {
    let text = "";
    let sep = "";
    if (Array.isArray(obj)) {
      if (!isClass) {
        throw qError(QError.Render_unsupportedFormat_obj_attr, obj, "style");
      }
      for (let i = 0; i < obj.length; i++) {
        text += sep + obj[i];
        sep = " ";
      }
    } else {
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          text += isClass ? value ? sep + key : "" : sep + fromCamelToKebabCase(key) + ":" + value;
          sep = isClass ? " " : ";";
        }
      }
    }
    return text;
  }
  return String(obj);
}
function notifyRender(hostElement) {
  assertDefined(hostElement.getAttribute(QHostAttr));
  const containerEl = getContainer(hostElement);
  assertDefined(containerEl);
  resumeIfNeeded(containerEl);
  const ctx = getContext(hostElement);
  const state = getRenderingState(containerEl);
  if (ctx.dirty) {
    return state.renderPromise;
  }
  ctx.dirty = true;
  const activeRendering = state.hostsRendering !== void 0;
  if (activeRendering) {
    state.hostsStaging.add(hostElement);
    return state.renderPromise.then((ctx2) => {
      if (state.hostsNext.has(hostElement)) {
        return state.renderPromise;
      } else {
        return ctx2;
      }
    });
  } else {
    state.hostsNext.add(hostElement);
    return scheduleFrame(containerEl, state);
  }
}
function scheduleFrame(containerEl, state) {
  if (state.renderPromise === void 0) {
    state.renderPromise = getPlatform(containerEl).nextTick(() => renderMarked(containerEl, state));
  }
  return state.renderPromise;
}
var SCHEDULE = Symbol("Render state");
function getRenderingState(containerEl) {
  let set = containerEl[SCHEDULE];
  if (!set) {
    containerEl[SCHEDULE] = set = {
      hostsNext: /* @__PURE__ */ new Set(),
      hostsStaging: /* @__PURE__ */ new Set(),
      renderPromise: void 0,
      hostsRendering: void 0
    };
  }
  return set;
}
async function renderMarked(containerEl, state) {
  state.hostsRendering = new Set(state.hostsNext);
  state.hostsNext.clear();
  const doc = getDocument(containerEl);
  const platform = getPlatform(containerEl);
  const renderingQueue = Array.from(state.hostsRendering);
  sortNodes(renderingQueue);
  const ctx = {
    doc,
    globalState: state,
    hostElements: /* @__PURE__ */ new Set(),
    operations: [],
    roots: [],
    containerEl,
    component: void 0,
    perf: {
      visited: 0,
      timing: []
    }
  };
  for (const el of renderingQueue) {
    if (!ctx.hostElements.has(el)) {
      ctx.roots.push(el);
      await renderComponent(ctx, getContext(el));
    }
  }
  if (ctx.operations.length === 0) {
    if (qDev) {
      if (typeof window !== "undefined" && window.document != null) {
        logDebug("Render skipped. No operations.");
        printRenderStats(ctx);
      }
    }
    postRendering(containerEl, state);
    return ctx;
  }
  return platform.raf(() => {
    executeContextWithSlots(ctx);
    if (qDev) {
      if (typeof window !== "undefined" && window.document != null) {
        printRenderStats(ctx);
      }
    }
    postRendering(containerEl, state);
    return ctx;
  });
}
function postRendering(containerEl, state) {
  state.hostsStaging.forEach((el) => {
    state.hostsNext.add(el);
  });
  state.hostsStaging.clear();
  state.hostsRendering = void 0;
  state.renderPromise = void 0;
  if (state.hostsNext.size > 0) {
    scheduleFrame(containerEl, state);
  }
}
function sortNodes(elements) {
  elements.sort((a, b) => a.compareDocumentPosition(b) & 2 ? 1 : -1);
}
var ProxyMapSymbol = Symbol("ProxyMapSymbol");
function getProxyMap(doc) {
  let map = doc[ProxyMapSymbol];
  if (!map) {
    map = doc[ProxyMapSymbol] = /* @__PURE__ */ new WeakMap();
  }
  return map;
}
function qObject(obj, proxyMap) {
  assertEqual(unwrapProxy(obj), obj, "Unexpected proxy at this location");
  if (obj == null || typeof obj !== "object") {
    throw new Error(`Q-ERROR: Only objects can be wrapped in 'QObject', got ` + debugStringify(obj));
  }
  if (obj.constructor !== Object) {
    throw new Error(`Q-ERROR: Only objects literals can be wrapped in 'QObject', got ` + debugStringify(obj));
  }
  return readWriteProxy(obj, proxyMap);
}
function _restoreQObject(obj, map, subs) {
  return readWriteProxy(obj, map, subs);
}
function readWriteProxy(target, proxyMap, subs) {
  if (!target || typeof target !== "object")
    return target;
  let proxy = proxyMap.get(target);
  if (proxy)
    return proxy;
  proxy = new Proxy(target, new ReadWriteProxyHandler(proxyMap, subs));
  proxyMap.set(target, proxy);
  return proxy;
}
var QOjectTargetSymbol = ":target:";
var QOjectSubsSymbol = ":subs:";
var QOjectOriginalProxy = ":proxy:";
var SetSubscriber = Symbol("SetSubscriber");
function unwrapProxy(proxy) {
  if (proxy && typeof proxy == "object") {
    const value = proxy[QOjectTargetSymbol];
    if (value)
      return value;
  }
  return proxy;
}
function wrap(value, proxyMap) {
  if (value && typeof value === "object") {
    if (isQrl(value)) {
      return value;
    }
    const nakedValue = unwrapProxy(value);
    if (nakedValue !== value) {
      return value;
    }
    if (qDev) {
      verifySerializable(value);
    }
    const proxy = proxyMap.get(value);
    return proxy ? proxy : readWriteProxy(value, proxyMap);
  } else {
    return value;
  }
}
var ReadWriteProxyHandler = class {
  constructor(proxyMap, subs = /* @__PURE__ */ new Map()) {
    this.proxyMap = proxyMap;
    this.subs = subs;
  }
  getSub(el) {
    let sub = this.subs.get(el);
    if (!sub) {
      this.subs.set(el, sub = /* @__PURE__ */ new Set());
    }
    return sub;
  }
  get(target, prop) {
    let subscriber = this.subscriber;
    this.subscriber = void 0;
    if (prop === QOjectTargetSymbol)
      return target;
    if (prop === QOjectSubsSymbol)
      return this.subs;
    if (prop === QOjectOriginalProxy)
      return this.proxyMap.get(target);
    const value = target[prop];
    if (typeof prop === "symbol") {
      return value;
    }
    if (!subscriber) {
      const invokeCtx = tryGetInvokeContext();
      if (qDev && !invokeCtx && !qTest) {
        logWarn(`State assigned outside invocation context. Getting prop "${prop}" of:`, target);
      }
      if (invokeCtx && invokeCtx.subscriptions && invokeCtx.hostElement) {
        subscriber = invokeCtx.hostElement;
      }
    }
    if (subscriber) {
      const isArray = Array.isArray(target);
      const sub = this.getSub(subscriber);
      if (!isArray) {
        sub.add(prop);
      }
    }
    return wrap(value, this.proxyMap);
  }
  set(target, prop, newValue) {
    if (typeof prop === "symbol") {
      if (prop === SetSubscriber) {
        this.subscriber = newValue;
      } else {
        target[prop] = newValue;
      }
      return true;
    }
    const unwrappedNewValue = unwrapProxy(newValue);
    verifySerializable(unwrappedNewValue);
    const isArray = Array.isArray(target);
    if (isArray) {
      target[prop] = unwrappedNewValue;
      this.subs.forEach((_, el) => notifyRender(el));
      return true;
    }
    const oldValue = target[prop];
    if (oldValue !== unwrappedNewValue) {
      target[prop] = unwrappedNewValue;
      this.subs.forEach((propSets, el) => {
        if (propSets.has(prop)) {
          notifyRender(el);
        }
      });
    }
    return true;
  }
  has(target, property) {
    if (property === QOjectTargetSymbol)
      return true;
    if (property === QOjectSubsSymbol)
      return true;
    return Object.prototype.hasOwnProperty.call(target, property);
  }
  ownKeys(target) {
    return Object.getOwnPropertyNames(target);
  }
};
function verifySerializable(value) {
  if (shouldSerialize(value) && typeof value == "object" && value !== null) {
    if (Array.isArray(value))
      return;
    if (isQrl(value))
      return;
    if (Object.getPrototypeOf(value) !== Object.prototype) {
      throw qError(QError.TODO, "Only primitive and object literals can be serialized.");
    }
  }
}
var NOSERIALIZE = Symbol("NoSerialize");
function shouldSerialize(obj) {
  if (obj !== null && (typeof obj == "object" || typeof obj === "function")) {
    const noSerialize2 = obj[NOSERIALIZE] === true;
    return !noSerialize2;
  }
  return true;
}
function noSerialize(input) {
  input[NOSERIALIZE] = true;
  return input;
}
function useSubscriber(obj) {
  return wrapSubscriber(obj, useHostElement());
}
function wrapSubscriber(obj, subscriber) {
  if (obj && typeof obj === "object") {
    const target = obj[QOjectTargetSymbol];
    if (!target) {
      return obj;
    }
    return new Proxy(obj, {
      get(target2, prop) {
        if (prop === QOjectOriginalProxy) {
          return target2;
        }
        target2[SetSubscriber] = subscriber;
        return target2[prop];
      }
    });
  }
  return obj;
}
function unwrapSubscriber(obj) {
  if (obj && typeof obj === "object") {
    const proxy = obj[QOjectOriginalProxy];
    if (proxy) {
      return proxy;
    }
  }
  return obj;
}
var runtimeSymbolId = 0;
var RUNTIME_QRL = "/runtimeQRL";
var EXTRACT_IMPORT_PATH = /\(\s*(['"])([^\1]+)\1\s*\)/;
var EXTRACT_SELF_IMPORT = /Promise\s*\.\s*resolve/;
var EXTRACT_FILE_NAME = /[\\/(]([\w\d.\-_]+\.(js|ts)x?):/;
function toInternalQRL(qrl2) {
  assertEqual(isQrl(qrl2), true);
  return qrl2;
}
function qrlImport(element, qrl2) {
  const qrl_ = toInternalQRL(qrl2);
  if (qrl_.symbolRef)
    return qrl_.symbolRef;
  if (qrl_.symbolFn) {
    return qrl_.symbolRef = qrl_.symbolFn().then((module) => qrl_.symbolRef = module[qrl_.symbol]);
  } else {
    if (!element) {
      throw new Error("QRL does not have an attached container");
    }
    const symbol = getPlatform(getDocument(element)).importSymbol(element, qrl_.chunk, qrl_.symbol);
    return qrl_.symbolRef = then(symbol, (ref) => {
      return qrl_.symbolRef = ref;
    });
  }
}
function qrl(chunkOrFn, symbol, lexicalScopeCapture = EMPTY_ARRAY) {
  let chunk;
  let symbolFn = null;
  if (typeof chunkOrFn === "string") {
    chunk = chunkOrFn;
  } else if (typeof chunkOrFn === "function") {
    symbolFn = chunkOrFn;
    let match;
    const srcCode = String(chunkOrFn);
    if ((match = srcCode.match(EXTRACT_IMPORT_PATH)) && match[2]) {
      chunk = match[2];
    } else if (match = srcCode.match(EXTRACT_SELF_IMPORT)) {
      const ref = "QWIK-SELF";
      const frames = new Error(ref).stack.split("\n");
      const start = frames.findIndex((f) => f.includes(ref));
      const frame = frames[start + 2];
      match = frame.match(EXTRACT_FILE_NAME);
      if (!match) {
        chunk = "main";
      } else {
        chunk = match[1];
      }
    } else {
      throw new Error("Q-ERROR: Dynamic import not found: " + srcCode);
    }
  } else {
    throw new Error("Q-ERROR: Unknown type argument: " + chunkOrFn);
  }
  if (Array.isArray(lexicalScopeCapture)) {
    for (let i = 0; i < lexicalScopeCapture.length; i++) {
      lexicalScopeCapture[i] = unwrapSubscriber(lexicalScopeCapture[i]);
    }
  }
  return new QRLInternal(chunk, symbol, null, symbolFn, null, lexicalScopeCapture);
}
function runtimeQrl(symbol, lexicalScopeCapture = EMPTY_ARRAY) {
  return new QRLInternal(RUNTIME_QRL, "s" + runtimeSymbolId++, symbol, null, null, lexicalScopeCapture);
}
function stringifyQRL(qrl2, opts = {}) {
  var _a;
  const qrl_ = toInternalQRL(qrl2);
  const symbol = qrl_.symbol;
  const platform = opts.platform;
  const element = opts.element;
  const chunk = platform ? (_a = platform.chunkForSymbol(symbol)) !== null && _a !== void 0 ? _a : qrl_.chunk : qrl_.chunk;
  const parts = [chunk];
  if (symbol && symbol !== "default") {
    parts.push("#", symbol);
  }
  const capture = qrl_.capture;
  const captureRef = qrl_.captureRef;
  if (opts.getObjId) {
    if (captureRef && captureRef.length) {
      const capture2 = captureRef.map(opts.getObjId);
      parts.push(`[${capture2.join(" ")}]`);
    }
  } else if (capture && capture.length > 0) {
    parts.push(`[${capture.join(" ")}]`);
  }
  const qrlString = parts.join("");
  if (qrl_.chunk === RUNTIME_QRL && element) {
    const qrls = element.__qrls__ || (element.__qrls__ = /* @__PURE__ */ new Set());
    qrls.add(qrl2);
  }
  return qrlString;
}
function parseQRL(qrl2, el) {
  const endIdx = qrl2.length;
  const hashIdx = indexOf(qrl2, 0, "#");
  const captureIdx = indexOf(qrl2, hashIdx, "[");
  const chunkEndIdx = Math.min(hashIdx, captureIdx);
  const chunk = qrl2.substring(0, chunkEndIdx);
  const symbolStartIdx = hashIdx == endIdx ? hashIdx : hashIdx + 1;
  const symbolEndIdx = captureIdx;
  const symbol = symbolStartIdx == symbolEndIdx ? "default" : qrl2.substring(symbolStartIdx, symbolEndIdx);
  const captureStartIdx = captureIdx;
  const captureEndIdx = endIdx;
  const capture = captureStartIdx === captureEndIdx ? EMPTY_ARRAY : qrl2.substring(captureStartIdx + 1, captureEndIdx - 1).split(" ");
  if (chunk === RUNTIME_QRL) {
    logError(`Q-ERROR: '${qrl2}' is runtime but no instance found on element.`);
  }
  const iQrl = new QRLInternal(chunk, symbol, null, null, capture, null);
  if (el) {
    iQrl.setContainer(el);
  }
  return iQrl;
}
function indexOf(text, startIdx, char) {
  const endIdx = text.length;
  const charIdx = text.indexOf(char, startIdx == endIdx ? 0 : startIdx);
  return charIdx == -1 ? endIdx : charIdx;
}
function toQrlOrError(symbolOrQrl) {
  if (!isQrl(symbolOrQrl)) {
    if (typeof symbolOrQrl == "function" || typeof symbolOrQrl == "string") {
      symbolOrQrl = runtimeQrl(symbolOrQrl);
    } else {
      throw new Error(`Q-ERROR Only 'function's and 'string's are supported.`);
    }
  }
  return symbolOrQrl;
}
function onUnmountQrl(unmountFn) {
  throw new Error("IMPLEMENT: onUnmount" + unmountFn);
}
var onUnmount$ = implicit$FirstArg(onUnmountQrl);
function onResumeQrl(resumeFn) {
  onWindow("load", resumeFn);
}
var onResume$ = implicit$FirstArg(onResumeQrl);
function onPauseQrl(dehydrateFn) {
  throw new Error("IMPLEMENT: onPause" + dehydrateFn);
}
var onPause$ = implicit$FirstArg(onPauseQrl);
function on(event, eventFn) {
  const el = useHostElement();
  const ctx = getContext(el);
  qPropWriteQRL(void 0, ctx, `on:${event}`, eventFn);
}
function onDocument(event, eventFn) {
  const el = useHostElement();
  const ctx = getContext(el);
  qPropWriteQRL(void 0, ctx, `on-document:${event}`, eventFn);
}
function onWindow(event, eventFn) {
  const el = useHostElement();
  const ctx = getContext(el);
  qPropWriteQRL(void 0, ctx, `on-window:${event}`, eventFn);
}
function useStylesQrl(styles) {
  _useStyles(styles, false);
}
var useStyles$ = implicit$FirstArg(useStylesQrl);
function useScopedStylesQrl(styles) {
  _useStyles(styles, true);
}
var useScopedStyles$ = implicit$FirstArg(useScopedStylesQrl);
function componentQrl(onMount, options = {}) {
  var _a;
  const tagName = (_a = options.tagName) !== null && _a !== void 0 ? _a : "div";
  return function QComponent(props, key) {
    const onRenderFactory = async (hostElement) => {
      const onMountQrl = toQrlOrError(onMount);
      const onMountFn = await resolveQrl(hostElement, onMountQrl);
      const ctx = getContext(hostElement);
      const props2 = getProps(ctx);
      const invokeCtx = newInvokeContext(getDocument(hostElement), hostElement, hostElement);
      const renderQRL = await useInvoke(invokeCtx, onMountFn, props2);
      return {
        renderQRL,
        waitOn: await promiseAll(invokeCtx.waitOn || [])
      };
    };
    onRenderFactory.__brand__ = "QRLFactory";
    return jsx(tagName, Object.assign({ [OnRenderProp]: onRenderFactory }, props), key);
  };
}
function component$(onMount, options) {
  return componentQrl($(onMount), options);
}
function resolveQrl(hostElement, onMountQrl) {
  return onMountQrl.symbolRef ? Promise.resolve(onMountQrl.symbolRef) : Promise.resolve(null).then(() => {
    return onMountQrl.resolve(hostElement);
  });
}
function _useStyles(styles, scoped) {
  const styleQrl = toQrlOrError(styles);
  const styleId = styleKey(styleQrl);
  const hostElement = useHostElement();
  if (scoped) {
    hostElement.setAttribute(ComponentScopedStyles, styleId);
  }
  useWaitOn(styleQrl.resolve(hostElement).then((styleText) => {
    const task = {
      type: "style",
      scope: styleId,
      content: scoped ? styleText.replace(/�/g, styleId) : styleText
    };
    return task;
  }));
}
function snapshot(elmOrDoc) {
  const doc = getDocument(elmOrDoc);
  const data = snapshotState(elmOrDoc);
  const parentJSON = isDocument(elmOrDoc) ? elmOrDoc.body : elmOrDoc;
  const script = doc.createElement("script");
  script.setAttribute("type", "qwik/json");
  script.textContent = JSON.stringify(data, void 0, qDev ? "  " : void 0);
  parentJSON.appendChild(script);
}
function useProps() {
  const ctx = getInvokeContext();
  let props = ctx.props;
  if (!props) {
    props = ctx.props = getProps(getContext(useHostElement()));
  }
  return props;
}
var ON_WATCH = "on:qWatch";
function registerOnWatch(element, props, watchFnQrl) {
  props[ON_WATCH] = watchFnQrl;
  invokeWatchFn(element, watchFnQrl);
}
var cleanupFnMap = /* @__PURE__ */ new Map();
async function invokeWatchFn(element, watchFnQrl) {
  const watchFn = await watchFnQrl.resolve(element);
  const previousCleanupFn = cleanupFnMap.get(watchFn);
  cleanupFnMap.delete(watchFn);
  if (isCleanupFn(previousCleanupFn)) {
    try {
      previousCleanupFn();
    } catch (e) {
      logError(e);
    }
  }
  throw new Error("TO IMPLEMENT");
}
function isCleanupFn(value) {
  return typeof value === "function";
}
function onWatchQrl(watchFn) {
  registerOnWatch(useHostElement(), useProps(), watchFn);
}
var onWatch$ = implicit$FirstArg(onWatchQrl);
function Async(props) {
  if (!("children" in props)) {
    throw new Error("IMPLEMENT");
  }
  const children = [props.children].flat()[0];
  const renderFn = typeof children == "function" ? children : null;
  const promiseValue = {
    isPending: true,
    isResolved: false,
    value: void 0,
    isRejected: false,
    rejection: void 0
  };
  let pending;
  const jsxPromise = new Promise((resolve, reject) => {
    pending = renderFn && renderFn(promiseValue);
    Promise.resolve(props.resolve).then((value) => {
      promiseValue.isPending = false;
      promiseValue.isResolved = true;
      promiseValue.value = value;
      return resolve(renderFn && renderFn(promiseValue));
    }, (error) => {
      promiseValue.isPending = false;
      promiseValue.isRejected = true;
      promiseValue.rejection = error;
      return reject(renderFn && renderFn(promiseValue));
    });
  });
  jsxPromise.whilePending = pending;
  return jsxPromise;
}
function h(type, props, ...children) {
  const normalizedProps = {
    children: arguments.length > 2 ? flattenArray(children) : EMPTY_ARRAY
  };
  let key;
  let i;
  for (i in props) {
    if (i == "key")
      key = props[i];
    else
      normalizedProps[i] = props[i];
  }
  return new JSXNodeImpl(type, normalizedProps, key);
}
var Slot = (props) => {
  const hasChildren = props.children || Array.isArray(props.children) && props.children.length > 0;
  const newChildrem = !hasChildren ? [] : jsx("q:fallback", {
    children: props.children
  });
  return jsx("q:slot", {
    name: props.name,
    children: newChildrem
  }, props.name);
};
var version = "0.0.18-5-dev20220324200307";
function render(parent, jsxNode) {
  if (!isJSXNode(jsxNode)) {
    jsxNode = jsx(jsxNode, null);
  }
  const doc = getDocument(parent);
  const containerEl = getElement(parent);
  resumeIfNeeded(containerEl);
  injectQVersion(containerEl);
  const ctx = {
    doc,
    globalState: getRenderingState(containerEl),
    hostElements: /* @__PURE__ */ new Set(),
    operations: [],
    roots: [parent],
    component: void 0,
    containerEl,
    perf: {
      visited: 0,
      timing: []
    }
  };
  return then(visitJsxNode(ctx, parent, processNode(jsxNode), false), () => {
    executeContext(ctx);
    if (!qTest) {
      injectQwikSlotCSS(parent);
    }
    if (qDev) {
      if (typeof window !== "undefined" && window.document != null) {
        printRenderStats(ctx);
      }
    }
    return ctx;
  });
}
function injectQwikSlotCSS(docOrElm) {
  const doc = getDocument(docOrElm);
  const element = isDocument(docOrElm) ? docOrElm.head : docOrElm;
  const style = doc.createElement("style");
  style.setAttribute("id", "qwik/base-styles");
  style.textContent = `q\\:slot{display:contents}q\\:fallback{display:none}q\\:fallback:last-child{display:contents}`;
  element.insertBefore(style, element.firstChild);
}
function getElement(docOrElm) {
  return isDocument(docOrElm) ? docOrElm.documentElement : docOrElm;
}
function injectQVersion(containerEl) {
  containerEl.setAttribute("q:version", version || "");
  containerEl.setAttribute(QContainerAttr, "");
}
function useDocument() {
  const doc = getInvokeContext().doc;
  if (!doc) {
    throw new Error("Cant access document for existing context");
  }
  return doc;
}
function useEvent(expectEventType) {
  const event = getInvokeContext().event;
  expectEventType && assertEqual(event.type, expectEventType);
  return event;
}
function useURL() {
  const url = getInvokeContext().url;
  if (!url) {
    throw new Error("Q-ERROR: no URL is associated with the execution context");
  }
  return url;
}
function useLexicalScope() {
  var _a;
  const context = getInvokeContext();
  const hostElement = context.hostElement;
  const qrl2 = (_a = context.qrl) !== null && _a !== void 0 ? _a : parseQRL(decodeURIComponent(String(useURL())), hostElement);
  if (qrl2.captureRef == null) {
    const el = context.element;
    assertDefined(el);
    resumeIfNeeded(getContainer(el));
    const ctx = getContext(el);
    qrl2.captureRef = qrl2.capture.map((idx) => qInflate(idx, ctx));
  }
  if (context.subscriptions && hostElement) {
    return qrl2.captureRef.map((obj) => wrapSubscriber(obj, hostElement));
  }
  return qrl2.captureRef;
}
function useStore(initialState) {
  return qObject(initialState, getProxyMap(useDocument()));
}

export {
  setPlatform,
  getPlatform,
  useHostElement,
  Host,
  SkipRerender,
  $,
  implicit$FirstArg,
  jsx,
  Fragment,
  notifyRender,
  noSerialize,
  useSubscriber,
  wrapSubscriber,
  unwrapSubscriber,
  qrl,
  onUnmountQrl,
  onUnmount$,
  onResumeQrl,
  onResume$,
  onPauseQrl,
  onPause$,
  on,
  onDocument,
  onWindow,
  useStylesQrl,
  useStyles$,
  useScopedStylesQrl,
  useScopedStyles$,
  componentQrl,
  component$,
  snapshot,
  onWatchQrl,
  onWatch$,
  Async,
  h,
  Slot,
  version,
  render,
  useDocument,
  useEvent,
  useLexicalScope,
  useStore
};
/**
 * @license
 * Copyright Builder.io, Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/BuilderIO/qwik/blob/main/LICENSE
 */
/**
 * @license
 * Copyright Builder.io; Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/BuilderIO/qwik/blob/main/LICENSE
 */
//# sourceMappingURL=chunk-YFD77ZGK.js.map
